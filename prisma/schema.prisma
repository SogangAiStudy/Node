generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                 String          @id @default(cuid())
  name               String?
  email              String          @unique
  image              String?
  createdAt          DateTime        @default(now())
  emailVerified      DateTime?
  accounts           Account[]
  activityLogs       ActivityLog[]
  ownedNodes         Node[]          @relation("NodeOwner")
  orgMemberships     OrgMember[]
  ownedOrganizations Organization[]  @relation("OrganizationOwner")
  projectMemberships ProjectMember[]
  ownedProjects      Project[]       @relation("ProjectOwner")
  approvedRequests   Request[]       @relation("RequestApprover")
  createdRequests    Request[]       @relation("RequestCreator")
  assignedRequests   Request[]       @relation("RequestAssignee")
  sessions           Session[]
  teamMemberships    TeamMember[]
  nodeOwners         NodeOwner[]
  orgInboxStates     OrgInboxState[]
  sentInvites        ProjectInvite[] @relation("InvitedBy")
  receivedInvites    ProjectInvite[] @relation("TargetUser")
  notifications      Notification[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Organization {
  id           String        @id @default(cuid())
  name         String
  inviteCode   String?       @unique
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  ownerId      String
  
  // Stripe subscription fields
  stripeCustomerId         String?   @unique @map("stripe_customer_id")
  stripeSubscriptionId     String?   @unique @map("stripe_subscription_id")
  stripePriceId            String?   @map("stripe_price_id")
  stripeSubscriptionStatus String?   @map("stripe_subscription_status")
  stripeCurrentPeriodEnd   DateTime? @map("stripe_current_period_end")
  
  // Node count for efficient limit checking
  nodeCount    Int           @default(0) @map("node_count")
  
  activityLogs ActivityLog[]
  edges        Edge[]
  nodes        Node[]
  members      OrgMember[]
  owner        User            @relation("OrganizationOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  projects     Project[]
  requests     Request[]
  teams        Team[]
  folders      Folder[]
  inboxStates  OrgInboxState[]
  invites      ProjectInvite[]
  notifications Notification[]

  @@index([ownerId])
  @@map("organizations")
}

model OrgMember {
  id           String          @id @default(cuid())
  orgId        String
  userId       String
  role         OrgRole         @default(MEMBER)
  status       OrgMemberStatus @default(PENDING_TEAM_ASSIGNMENT)
  createdAt    DateTime        @default(now())
  organization Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([orgId])
  @@index([userId])
  @@map("org_members")
}

model Team {
  id              String        @id @default(cuid())
  orgId           String
  name            String
  description     String?
  createdAt       DateTime      @default(now())
  nodes           Node[]
  projectTeams    ProjectTeam[]
  primaryProjects Project[]     @relation("PrimaryTeam")
  members         TeamMember[]
  nodeTeams       NodeTeam[]
  organization    Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, name])
  @@index([orgId])
  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  orgId     String
  teamId    String
  userId    String
  role      TeamRole @default(MEMBER)
  createdAt DateTime @default(now())
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, teamId, userId])
  @@index([teamId])
  @@index([userId])
  @@map("team_members")
}

model ProjectTeam {
  id        String      @id @default(cuid())
  orgId     String
  projectId String
  teamId    String
  role      ProjectRole @default(VIEWER)
  createdAt DateTime    @default(now())
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team      Team        @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([projectId, teamId])
  @@index([projectId])
  @@index([teamId])
  @@map("project_teams")
}

model Project {
  id            String          @id @default(cuid())
  name          String
  createdAt     DateTime        @default(now())
  description   String?
  orgId         String
  primaryTeamId String?
  updatedAt     DateTime        @updatedAt
  sortOrder         Float           @default(0)
  ownerId       String
  activityLogs  ActivityLog[]
  edges         Edge[]
  nodes         Node[]
  members       ProjectMember[]
  projectTeams  ProjectTeam[]
  invites      ProjectInvite[]
  organization Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  owner         User            @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  primaryTeam   Team?           @relation("PrimaryTeam", fields: [primaryTeamId], references: [id])
  requests      Request[]
  folderId      String?
  folder        Folder?        @relation(fields: [folderId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([ownerId])
  @@index([primaryTeamId])
  @@map("projects")
}

model ProjectMember {
  id         String      @id @default(cuid())
  orgId      String
  projectId  String
  userId     String
  role       ProjectRole @default(EDITOR)
  isFavorite Boolean     @default(false)
  createdAt  DateTime    @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([orgId])
  @@map("project_members")
}

model ProjectInvite {
  id              String              @id @default(cuid())
  orgId           String
  projectId       String
  invitedByUserId String
  targetUserId    String
  status          ProjectInviteStatus @default(PENDING)
  createdAt       DateTime            @default(now())
  respondedAt     DateTime?

  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  invitedBy    User         @relation("InvitedBy", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser   User         @relation("TargetUser", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@unique([projectId, targetUserId])
  @@index([orgId])
  @@map("project_invites")
}

model Node {
  id             String       @id @default(cuid())
  projectId      String
  title          String
  description    String?
  type           NodeType     @default(TASK)
  manualStatus   ManualStatus @default(TODO)
  ownerId        String?
  priority       Int          @default(3)
  dueAt          DateTime?
  phase          String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  orgId          String
  teamId         String?
  positionX      Float?
  positionY      Float?
  edgesFrom      Edge[]       @relation("EdgeFrom")
  edgesTo        Edge[]       @relation("EdgeTo")
  organization   Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  owner          User?        @relation("NodeOwner", fields: [ownerId], references: [id])
  project        Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team           Team?        @relation(fields: [teamId], references: [id])
  nodeTeams      NodeTeam[]
  nodeOwners     NodeOwner[]
  linkedRequests Request[]

  @@index([orgId])
  @@index([projectId])
  @@index([teamId])
  @@index([ownerId])
  @@map("nodes")
}

model NodeTeam {
  nodeId String
  teamId String
  node   Node   @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@id([nodeId, teamId])
  @@map("node_teams")
}

model NodeOwner {
  nodeId String
  userId String
  node   Node   @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([nodeId, userId])
  @@map("node_owners")
}

model Edge {
  id           String       @id @default(cuid())
  projectId    String
  fromNodeId   String
  toNodeId     String
  relation     EdgeRelation
  createdAt    DateTime     @default(now())
  orgId        String
  fromNode     Node         @relation("EdgeFrom", fields: [fromNodeId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  toNode       Node         @relation("EdgeTo", fields: [toNodeId], references: [id], onDelete: Cascade)

  @@unique([projectId, fromNodeId, toNodeId, relation])
  @@index([orgId])
  @@index([projectId])
  @@index([fromNodeId])
  @@index([toNodeId])
  @@map("edges")
}

model Request {
  id            String        @id @default(cuid())
  projectId     String
  linkedNodeId  String
  question      String
  fromUserId    String
  toUserId      String?
  toTeam        String?
  status        RequestStatus @default(OPEN)
  responseDraft String?
  responseFinal String?
  approvedById  String?
  approvedAt    DateTime?
  claimedAt     DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  isArchived    Boolean       @default(false)
  orgId         String
  approvedBy    User?         @relation("RequestApprover", fields: [approvedById], references: [id])
  fromUser      User          @relation("RequestCreator", fields: [fromUserId], references: [id], onDelete: Cascade)
  linkedNode    Node          @relation(fields: [linkedNodeId], references: [id], onDelete: Cascade)
  organization  Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  project       Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  toUser        User?         @relation("RequestAssignee", fields: [toUserId], references: [id])

  @@index([orgId])
  @@index([projectId])
  @@index([linkedNodeId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([status])
  @@map("requests")
}

model ActivityLog {
  id           String       @id @default(cuid())
  projectId    String
  userId       String
  action       String
  entityType   String
  entityId     String
  details      Json?
  createdAt    DateTime     @default(now())
  orgId        String
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([projectId])
  @@index([userId])
  @@index([createdAt])
  @@map("activity_logs")
}

model OrgInboxState {
  id         String       @id @default(cuid())
  orgId      String
  userId     String
  lastSeenAt DateTime     @default(now())
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([orgId])
  @@index([userId])
  @@map("org_inbox_states")
}

enum OrgRole {
  ADMIN
  MEMBER
}

enum OrgMemberStatus {
  ACTIVE
  PENDING_TEAM_ASSIGNMENT
  DEACTIVATED
  PENDING_APPROVAL
}

enum TeamRole {
  LEAD
  MEMBER
}

enum ProjectRole {
  OWNER
  PROJECT_ADMIN
  EDITOR
  VIEWER
}

enum ProjectInviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum NodeType {
  TASK
  DECISION
  BLOCKER
  INFOREQ
}

enum ManualStatus {
  TODO
  DOING
  DONE
}

enum EdgeRelation {
  DEPENDS_ON
  HANDOFF_TO
  NEEDS_INFO_FROM
  APPROVAL_BY
}

enum RequestStatus {
  OPEN
  RESPONDED
  APPROVED
  CLOSED
}

model Notification {
  id           String           @id @default(cuid())
  userId       String?          // Null if targeted at a team
  orgId        String
  type         NotificationType
  targetType   NotificationTargetType @default(USER)
  targetTeamId String?          // ID of the team if targetType is TEAM
  title        String
  message      String?
  entityId     String?          // ID of the related object (Node, Project, etc.)
  isRead       Boolean          @default(false)
  dedupeKey    String?          @unique
  createdAt    DateTime         @default(now())
  
  user         User?          @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([orgId])
  @@index([targetTeamId])
  @@map("notifications")
}

enum NotificationType {
  NODE_UNBLOCKED
  NODE_ASSIGNED
  NODE_UPDATED
  PROJECT_ASSIGNED
  TEAM_ASSIGNED
  MENTION
  SYSTEM
}

enum NotificationTargetType {
  USER
  TEAM
}

model Folder {
  id          String   @id @default(cuid())
  orgId       String
  name        String
  description String?
  color       String   @default("#3b82f6")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  sortOrder   Float    @default(0)

  // Hierarchy
  parentId    String?
  parent      Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade) // Cascade delete subfolders? Maybe. Or SetNull. Let's say Cascade for now or user might lose access. User said "Folder (can be nested)".
  children    Folder[] @relation("FolderHierarchy")

  projects    Project[]

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, name, parentId]) // Unique name per folder level? Or just unique per org? Original was [orgId, name]. With nesting, unique per parentId is better, but Prisma might complain about unique constraint if parentId is null.
  // Let's keep @@unique([orgId, name]) for now effectively forcing unique folder names in the org, which is simpler but less flexible. If user wants duplicate names in different subfolders, we change later.
  // Actually, standard FS allows same name in different folders.
  // Let's remove the unique constraint on name for now or make it per-parent?
  // User didn't specify. I'll stick to simple unique constraint removal or per parent?
  // Let's keep loose for now to avoid migration errors.
  
  @@map("folders")
}
